## 一 ElasticSearch简介
### 1.1 ElasticSearch是什么?
✅ 第一: ElasticSearch是一个开源的基于Lucene实现的高性能的近实时的分布式的搜索和分析引擎  
✅ 第二: 可以用于大规模数据存储、近实时的搜索和分析  
✅ 第三: 被广泛应用日志分析、实时数据分析、全文搜索等领域  

### 1.2 ElasticSearch有哪些角色
✅ Master Node: 负责管理集群，比如索引创建等  
✅ Data Node: 负责数据的存储和查询  
✅ Coordinate Node: 负责接受请求和分发请求以及聚合结果  
✅ Ingest Node: 负责预处理文档，可作为数据清洗入口  

### 1.3 ElasticSearch架构
#### 1.3.1 ElasticSearch中索引、分片、段、文档之间的关系如何？
✅ 索引就是一个逻辑上的数据集合 ，索引可以分为多个分片  
✅ 每一个分片本质上就是一个Lucene索引，所以一个分片包含多个段，段可能会有大有小，段合并(Segment Merge)可以将将多个小段合并成大段  
✅ 一个段又包含多个文档，或者说文档是存储在段文件中的  

#### 1.3.2 如何实现分布式架构
✅ 一个索引分成多个分片  
✅ 每一个分片又可以分为主分片和副本分片，这样可以避免分片单点故障问题  
✅ 主分片负责对外提供读写；副本分片负责提供读功能，并且需要从主分片同步数据  
✅ 主分片和副本分片将会分散到集群中数据节点上  


### 1.4 ElasticSearch为什么这么快?
#### 1.4.1 分布式架构
✅ 采用分片+并发的机制，使得搜索的时候可以从多个分片中查询数据后进行聚合  
✅ 查询压力会分摊到所有节点和副本上，方便线性扩展  

#### 1.4.2 倒排索引
✅ 底层基于Lucene的倒排索引机制，查询关键词时，不用遍历所有文档，直接命中匹配文档  

#### 1.4.3 缓存
✅ ElasticSearch使用了大量的缓存，比如Filter Cache、Query Cache等等，有利于提升查询性能  

#### 1.4.4 支持批量写
✅ 可以通过批量写入，减少I/O次数  

#### 1.4.5 高效的数据结构和压缩
✅ Lucene底层数据结构做了很多优化，字段压缩、FST压缩等  

## 二 ElasticSearch写请求的工作原理
### 2.1 协调节点
✅ 协调节点收到请求后，根据索引获取主分片信息, 如果索引不存在则创建索引  
✅ 根据docId计算落在哪一个主分片  
✅ 根据主分片信息，获取对应的数据节点  
✅ 转发写请求到对应的数据节点  
✅ 根据主分片响应结果返回到客户端  

### 2.2 主分片节点
✅ 主分片节点收到写请求，将数据写入本地IndexBuffer缓冲区，同时写入事务日志translog中  
✅ 根据刷盘策略，判断是不是同步刷盘，如果是还需要进行同步刷盘  
✅ 主分片节点将数据同步给副本分片节点，等待副本分片节点完成响应后，才返回响应给协调节点   

### 2.3 副本分片节点
✅ 副本分片节点收到写请求，将数据写入本地IndexBuffer缓冲区，同时写入事务日志translog中  
✅ 根据刷盘策略，判断是不是同步刷盘，如果是还需要进行同步刷盘  
✅ 副本分片完成数据同步后，响应主分片节点  

## 三 ElasticSearch读请求的工作原理

### 3.1 Get请求工作原理
#### 3.1.1 协调节点
✅ 协调节点收到客户端Get请求后，根据索引找到分片信息  
✅ 根据docId计算落到哪一个分片  
✅ 然后会从这个分片的主分片和副本分片中任选一个发起请求  
✅ 根据分片节点返回数据响应客户端请求  

#### 3.1.2 分片节点
✅ 收到协调节点发送的请求  
✅ 根据docId查询，返回查询文档返回给协调节点  

### 3.2 Search请求工作原理

#### 3.2.1 Query阶段
🎯 **协调节点**  
✅ 协调节点收到客户端Search请求后, 根据索引获取所有分片信息  
✅ 从对应的分片中选择一个主分片或者副本分片发送Search请求  
✅ 收到个分片返回的数据  

🎯 **分片节点**  
✅ 各个分片节点收到search请求，获取from和size参数，如果没有默认from=0,size=10  
✅ 执行Search请求，根据打分结果排序，然后返回from+size决定返回这些文档的docId  


#### 3.2.2 Fetch阶段
🎯 **协调节点**  
✅ 收到各个节点返回的数据，然后根据打分结果，放入一个列表  
✅ 然后根据from + size参数获取size个docId  
✅ 然后通过get请求获取docId对应的文档  
✅ 将Get请求返回的结果进行汇总，然后返回给客户端  

🎯 **分片节点**  
✅ 收到协调节点发送的请求   
✅ 根据docId查询，返回查询文档返回给协调节点   

## 四 ElasticSearch故障转移流程
### 4.1 Master Node故障
🎯 **故障检测**
✅ 具备Master资格的节点会通过和Master Node的TCP长连接，每隔一段时间，节点会通过这条 TCP 连接给 Master 节点发一个小的 ping 请求  
✅ 如果在配置的时间段内，连续多次没有收到 Master 的任何响应（ack/pong），就认为这条连接已经断了  

🎯 **发起选举**
✅ 只要当前节点具备 Master 资格（node.master: true），就会尝试参与选举  
✅ 在多个候选 Master 中，ES 会选择:
✅ 集群状态（clusterState.version）最新的节点  
✅ 如果版本相同，则选择 NodeId 最大的那个节点  

### 4.2 Data Node故障
🎯 **故障检测**
✅ 非 Master 节点会主动定期向 Master 节点发送心跳，用于向 Master 汇报自己的状态。而 Master 节点通过这些心跳判断哪些节点还活

🎯 **故障转移**
✅ Master 通知并更新集群状态，将该故障节点从集群节点列表中移除，标记该节点不可用  
✅ 数据副本迁移和分片恢复  
✅ Data 节点故障，该节点上的所有主分片或副本分片无法访问  
✅ 根据主分片找到在其他节点上副本分片列表，然后选择一个副本分片提升为主分片  
✅ 并为新的主分片再生成副本，然后分配到集群中节点中  
✅ 新的副本分片会从新的主分片同步数据，保证数据冗余和一致性  
✅ 更新集群元数据，使得客户端等可以从集群元数据获取到最新的分片情况，集群状态恢复为绿色  

## 五 ElasticSearch如何保证数据不会丢失的
✅ 分布式架构，将索引分片存储，分散在集群中，降低了数据丢失的可能性  
✅ 采用副本机制，防止单分片所在节点故障  
✅ 采用快照和副本，可以将索引数据定期备份到远程存储中，以防止数据丢失。在发生灾难性故障或数据损坏时，可以使用备份数据来恢复索引  
✅ 通过事务日志translog防止内存中的索引数据还没有刷盘就发生宕机等造成数据丢失  

## 六 ElasticSearch中Filter和Query比较
### 6.1 是否参与打分
✅ Filter不会打分  
✅ Query会进行打分  

### 6.2 是否缓存结果
✅ Filter不会对结果缓存  
✅ Query会对结果缓存  

### 6.3 适合场景不同
✅ Filter适合精确匹配和范围查找  
✅ Query适合全文检索  

## 七 fielddata和doc_values比较
🔍 **背景:** 倒排索引的局限性，虽然性能高，但是不适合排序、聚合。因此，有时候需要使用正向索引，ElasticSearch提供了2种: fielddata和doc_values

### 7.1 fielddata
✅ 第一: fielddata是一种基于正向索引构建的、存储在内存中的列式数据结构  
✅ 第二: fielddata主要针对分词(Text)字段，可以对分词字段进行排序、聚合等，默认是关闭的  
✅ 第三: 基于内存存储，数据量大的时候，可能内存扛不住  
1. [ ] 对整个fielddata占用的内存做限制，超过阈值indices.fielddata.cache.size这个比例就清空当前fielddata
2. [ ] 允许针对fielddata使用的内存占总内存比例达到某一个阈值，或者某一次查询请求使用的fielddata占内存比例超过阈值等，就进行短路


### 7.2 doc_values
✅ 第一: doc_values是一种基于正向索引构建的、存储在磁盘中的列式数据结构  
✅ 第二: doc_values主要针对非分词字段，比如keyword、integer、double等这类型，可以对非分词字段进行排序聚合等  
✅ 第三: doc_values默认是开的，不需要的话可以关闭  

### 7.3 fielddata和doc_values比较
#### 7.3.1 相同点
✅ 第一: 都是基于正向索引构建的列式数据结构  
✅ 第二: 都可以用于聚合、排序场景  

#### 7.3.2 不同点
🎯 **存储方式不一样**  
➡️ fielddata存储在内存；doc_values基于page_cache和磁盘存储  

🎯 **针对字段不一样**  
➡️ fielddata是针对分词字段; doc_values针对的是非分词字段  

🎯 **是否默认开启**  
➡️ fielddata默认关闭；doc_values默认开启  

## 八 ElasticSearch中store、index、text、keyword、norms之间的区别
### 8.1 store
✅ 我们知道，索引并不是将文档原始内容存储起来。但是，有时候需要查询原始文档字段内容，就需要将这个字段设置成store, 这样查询返回的结果就可以包含该字段  
✅ 但是，每一个字段都开启store，就会进行一次I/O，因此，在生产环境，对于明确不需要返回的字段，可以设置成false, 减少I/O次数，提升查询效率  
✅ 但是在ElasticSearch中，默认会在第一个地方存储所有字段的原始的值，如果只希望返回某些字段的值，可以通过_source指定需要返回的字段，无论是返回所有字段还是单个字段都只会进行一次I/O  
✅ 当然，ElasticSearch也是支持store的。但是从性能角度来考虑，是没有必要将字段store设置为true的  

### 8.2 index
✅ index表示该字段需要索引，如果该字段明确知道不会进行索引，那么可以设置成false, 因为默认是true

### 8.3 text
✅ text字段表示该字段索引的胡思后，还可以被分词  

### 8.4 keyword
✅ 如果不需要搜索，那就意味着不需要被分词，可以使用keyword，只是索引，不会被分词  

### 8.5 norms
✅ norms用于计算文档的相关性分数，当一个字段被标记为norms, 意味着需要存储这个字段的norm值，然后在相关性评分的时候使用

## 九 ElasticSearch的refresh和flush比较
### 9.1 什么是refresh
✅ 索引并不是直接写入磁盘的，而是先写入内存中，也就是IndexBuffer，但是写入IndexBuffer索引是不能被查询的  
✅ 只有写入到操作系统page cache中或者刷盘后，索引才可以被查询  
✅ 所以，需要将IndexBuffer内存中的索引数据写入到page cache就是refresh   

### 9.2 什么是flush
✅ 指的是需要将Page Cache数据刷入到磁盘，包括Page Cache中的索引数据和索引日志数据translog  

### 9.3 refresh时机
✅ 第一: 可以通过API接口/refresh，手动refresh  
✅ 第二: 配置了refresh_interval刷新频率，定时任务会根据这个频率进行refresh  
✅ 第三: IndexBuffer索引缓冲区写满了，会自动refresh  
✅ 第四: 关闭索引的时候，既会refresh，也会触发flush操作  

### 9.4 flush时机
✅ 第一: 操作系统后台有定时任务会定时flush  
✅ 第二: 当ElasticSearch内存不足的时候，会将page cache中数据刷到磁盘  
✅ 第三: 关闭索引的时候，既会将IndexBuffer中的数据refresh, 还会进行flush操作  
✅ 第四: 当事务日志translog到期(默认30分钟)或者事务日志文件写满了(默认512mb)，也会将page cache刷盘  
✅ 第五: 如果开启了同步刷盘，每次写translog就会刷盘  