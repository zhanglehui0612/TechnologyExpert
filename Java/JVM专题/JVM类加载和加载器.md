## 一 类加载时机

✅ Main方法启动  
✅ 当创建类的实例的时候也需要加载类。比如执行new指令或者反射  
✅ 访问某个类的静态变量或者静态方法的时候，这个类也会被加载  
✅ 当子类加载的时候，如果有父类，也会被加载  
**注意:**  
1) 如果通过通过子类访问父类的静态变量或者静态方法，只会对父类进行类加载，子类是不会被加载的
2) 如果访问一个类的被static 和 final 同时修饰的常量，这个类是不会被加载的

## 二 类加载流程

### 2.1 加载
✅ 通过类的全限定名将字节码文件以二进制流的形式加载JVM内存  
✅ JVM内存中的方法区生成运行时数据，创建Class对象，位于元空间中  

### 2.2 链接
#### 2.2.1 验证
✅ 验证字节码文件格式  
✅ 验证类的元数据信息:比如继承的类是否被final修饰? 如果继承的是抽象类，有无实现抽象方法等  
✅ 验证符号引用: 是否可以根据全限定名找到对应的类，以及符号引用的对应的类是否可以被当前类访问等，确保可以解析阶段正常解析  

#### 2.2.2 准备
✅ 如果类有static修饰的成员变量，在这个阶段会进行内存分配和进行初始化。比如static int a = 10， 这时候就会初始化成a = 0; 比如final static long b = 100, 这个时候就会初始化成100  
✅ 普通静态变量在赋值的时候是在初始化阶段执行常量池中的cinit方法的时候才会进行。比如static int a = 10， 这时候才会真正的赋值a=10  
✅ 被static final 修饰的常量，在这个阶段会直接初始化赋值为常量值，不会初始化成0或者null。比如final static long b = 100, 这时候b就会赋值为100，而不是0  

#### 2.2.3 解析
✅ 解析就是将类的符号引号替换为直接引用地址  
✅ 因为编译时候，无法确定引用对象的真实地址是什么，所以通过一个唯一标识符号引用来表示，但是在加载的时候，就需要把符号引用替换成真实的直接引用地址  

### 2.3 初始化
✅ 在编译阶段，会生成一个<clinit>方法，该方法它包含了所有静态变量的显示赋值语句和所有静态代码块  
✅ 初始化阶段就是执行类构造器的阶段，或者说为静态变量真正赋值和执行静态代码块的阶段  
✅ 只有在首次主动使用类时才会触发初始化  
**注意: 初始化不代表实例化**  

### 2.4 使用
✅ 被初始化之后的类就可以被程序使用了，这时候就可以进行对象实例化，执行init方法，分配内存、初始化成员变量、执行构造器等

## 三 类加载器是什么，类加载器是怎么分类的以及是如何分类的
### 3.1 类加载器是什么
类加载器是 JVM 中负责将 .class 文件加载进内存，并生成对应 Class 对象的组件  

### 3.2 为什么需要类加载器？
模块隔离: 不同的模块或第三方库可以使用不同的类加载器加载，从而避免类名冲突
按需加载: 让应用程序根据需要，自己决定如何获取所需要的类

### 3.3 类加载器是怎么分类的
#### 3.3.1 根据上下级关系
根据上下级别关系可以分为父类加载器和子类加载器  

#### 3.3.2 站在虚拟机的角度
站在虚拟机的角度只有2类加载器：一种是JVM自身使用的启动类加载器，一种是其他类加载器  

#### 3.3.3 根据加载目录不同
👉 启动类加载器(Bootsrtrap ClassLoader): 属于JVM自身的类加载器，主要是加载$JAVA_HOME/lib目录下或者被-Xbootclasspath指定的路径下的类库，他也是属于顶级类加载器，没有父类加载器  
👉 扩展类加载器(Extension ClassLoader): JVM之外的主要用于加载$JAVA_HOME/lib/ext目录下的类库或者被指定参数java.ext.dirs系统变量指定路径下的类库,他的父类类加载器是启动类加载器  
👉 应用程序类加载器(Application ClassLoader)：JVM之外的主要用于加载用户classpath路径上的类加载器，应用程序如果没有定义过其他的系统类加载器，这个就是默认的，他的父类类加载器是扩展类加载器  


## 四 类加载器双亲委派模型
✅ 类加载器采用的工作模式是双亲委派模型  
✅ 当需要加载一个目标类的时候，类加载器会把这个加载请求或者任务委托给父类类加载器去加载，同样，父类类加载器也是委托给父类的父类类加载器去加载，这样直到类加载器没有父类，即到启动类加载器去加载  
✅ 启动类加载器可以加载，那么就会去完成加载动作；如果找不到目标类，无法加载目标类，那么就会由它的子类类加载器去完成加载动作；同理子类也无法加载，则由子类的子类类加载器来完成加载动作  

## 五 Tomcat类加载器工作机制
### 5.1 Tomcat的目录
👉 /common: tomcat server和web application都可以使用的类库  
👉 /catalina: tomcat server自己使用的类库  
👉 /shared: web application实例之间可以共用的类库，比如mysql等  
👉 /WEB-INF/classpath、/WEB-INF/lib等：web application每一个实例可以自己使用的类库  

### 5.2 Tomcat类加载器的结构
👉 启动类加载器(Bootsrtrap ClassLoader)  
👉 扩展类加载器(Extension ClassLoader)  
👉 应用程序类加载器(Application ClassLoader)  
👉 公共类加载器(Common ClassLoader)  
👉 Tomcat Server类加载器(Catalina ClassLoader)  
👉 Web应用共享类加载器(Sahred ClassLoader)  
👉 Web应用程序类加载器(WebApp ClassLoader)  

🎯 Common ClassLoader可以加载的类，都可以被Catalina ClassLoader和Shared ClassLoader使用，从而实现了类库的公用。但是Common ClassLoader和Shared ClassLoader他们自己能加载的类和对方都是相互隔离的  
🎯 Shared ClassLoader能加载的类可以被不同的WebApp实例共享，但是每个实例各自加载的类相互独立  

### 5.3 Tomcat类加载器是如何打破双亲委派机制
✅ 每一个web应用都用自己的类加载器，这些类加载器可以覆盖父类类加载器的逻辑  
✅ Web应用程序类加载器会尝试先从本地classpath和lib库去加载，如果不存在无法加载，才委托给父类类加载器，比如公共的一些类库。而不是直接委托给父类，父类加载不到才自己去加载   
✅ 双亲委派机制是委派给父类，不是先自己尝试加载  

## 七 对象的创建流程
### 7.1 创建对象
开始创建对象，比如new或者反射等  
此时会判断这个目标类是不是已经加载过,如果还没有加载过则走类加载流程  

### 7.2 对象分配内存
如果已经加载了则创建对象，分配内存。内存的大小在类加载完成后就可以确定下来  

### 7.3 对象初始化
对象成员字段初始化赋值，比如int类型赋值0， 字符串类型赋值null等  

### 7.4 开始执行实例构造方法
init方法是代码编译之后在字节码文件中生成的，和clinit一样的。只不过clinit发生在类加载的初始过程中  
此时进行成员变量赋值、执行构造代码块和构造方法等  

### 7.5 设置对象引用
比如A a = new A(); 此时就要把创建的A实例对象赋给引用a  

