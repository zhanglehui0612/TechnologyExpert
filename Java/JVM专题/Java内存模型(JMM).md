## 一 并发代码BUG根源

### 1.1 可见性问题
第一: 单核CPU不存在这个问题  
第二: 多核CPU场景下，线程A改变了共享变量值，线程B可能无法感知，因为他们操作的可能是不同核心

### 1.2 原子性问题
就是一个线程还没有执行完，CPU就去调度了其他线程，就有可能导致共享变量的不一致  

### 1.3 指令重排序问题
int i = 1;  
int j = i;  
int i = 2;  
CPU为了提升性能，会对指令进行重新排序，假设这里重排序之后是这样的： int i = 2； int j = i ; int i =1;显这已经改变了我们要的正确结果。本来j = 1的，但是现在2


## 二 什么是JMM
JMM是Java内存模型的缩写。是JVM虚拟机规范中定义的一套共享变量如何在多线程之间共享和交互的内存模型和行为语义  
在并发编程中，JMM 要解决以下几个核心问题:  
✅ 可见性	一个线程修改了共享变量，其他线程能否立即看到？  
✅ 原子性	对共享变量的操作是否是不可被中断的整体操作？  
✅ 有序性	代码的执行顺序是否与编写顺序一致？（编译器/CPU 会重排序）  


## 三 主内存和工作内存是如何工作的
✅ 共享变量是保存在主内存中的  
✅ 每一个线程都有一个自己的工作内存，存放主内存变量副本  
✅ 每一个线程只允许操作自己工作内存中的变量， 不能直接操作主内存的共享变量  
✅ 线程之间无法访问对方线程中工作内存中的共享变量  
✅ 如果需要在线程之间传递共享变量或者将工作内存中变量同步给其他线程，那么需要通过主内存来进行  

**主内存和工作内存交互的操作主要包括以下几个指令:**  


🔍 **工作内存中变脸更新到主内存**  
✅ **assign**  
CPU改变工作内存中变量的值

✅ **store**  
线程将工作内存中变量副本传递给主内存

✅ **lock**  
如果要将工作内存的变量副本更新主内存，需要先对主内存变量上锁，然后进行更新，在上锁期间其他线程是不能访问的  

✅ **write**  
主内存用工作内存的值更新变量

✅ **unlock**  
当主内存的更新完毕之后，即write之后，需要释放变量的锁，其他线程此时可以加锁



🔍 **从主内存读取共享变量**  
✅ **read**  
从主内存读取工作变量

✅ **load**  
将读取的主内存变量加载到工作内存，更新工作内存变量

✅ **use**  
CPU就可以使用更新后的工作内存变量


## 四 按需禁用

🔍 **什么是按需禁用?**  
✅ 我们知道，多线程会存在可见性、原子性和有序性问题，这些问题的原因在于CPU缓存、编译优化、线程切换等。那么我们禁止程序使用CPU缓存或者编译优化等，是不是就避免这个问题。  
✅ JMM把这个选择权交给了程序员，由我们自己决定是否需要禁用CPU缓存或者禁用编译优化。  
✅ 因此，JMM提供了volatile，synchronized，final三个关键字 和 六项happens-before规则。  


## 五 volatile、synchronized、final关键字

### 5.1 volatile
🔍 **volatile提供了2种语义:**  
✅ 禁用CPU缓存，保证共享变量对所有线程可见性  
✅ 禁止指令重排序

🔍  **保证共享变量对所有线程可见性**  
✅ 本质上就是，当前线程更新完工作内存中的共享变量，则会把共享变量同步到主内存；并且其他线程读取变量强制从主内存重新读取共享变量   
✅ 共享变量对于其他线程立马可见并不意味着volatile可以保证操作的原子性  
✅ 比如有个count++这个操作，只能保证当前线程count值改变后，其余线程立马可见；但不代表count++这个动作是线程同步的  

🔍  **禁止指令重排序**  
✅ 禁止指令重排序，可以明确告诉编译器volatile类型的变量操作的时候，他后面的指令重排序的时候不能在它之前  
✅ 前面操作是读volatile变量，后面的操作不能进行重排序，确保volatile读之后的操作不会被编译器重排序到volatile读之前  
✅ 如果后面的操作是volatile写，则前面的操作不能进行指令重排序，确保写之前的操作不会重排到volatile写之后  


### 5.2 synchronized
✅ synchronized需要依赖操作系统的互斥锁，一个线程持有锁，其他线程会被当前持有锁的线程阻塞等待  
✅ 当线程获取锁，JMM会先把该线程的工作内存中的共享变量的副本置为无效，从而使得被保护的临界区代码必须从主存中重新读取共享变量  
✅ 当线程释放锁时，JMM会把该线程对应的工作内存中的共享变量刷新到主内存中  
✅ 因此它的结果对于后面的其他线程是可见的，所以它既保证了原子性又保证了可见性  


### 5.3 final
✅ JMM禁止编译器把final域的写重排序到构造函数外，他会在final域写之后，返回之前插入一个内存屏障，这个屏障可以禁止处理器把final域的写重排序到构造函数之外  
✅ 言外之意，就是final 字段可以保证任意线程可见之前，final字段已经在构造函数正确被初始化了，但是普通字段不具有这个保障

```java
class FinalFieldExample {
    final int x;
    int y;
    static FinalFieldExample f;

    public FinalFieldExample() {
        x = 3;
        y = 4;
    }

    static void writer() {
        f = new FinalFieldExample();
    }

    static void reader() {
        if (f != null) {
            int i = f.x;  // 可以保证肯定是3
            int j = f.y;  // 不一定是4，有可能是0，即构造函数中就没有初始化，而是重排序到了构造函数之外
        }
    }
}
```

## 六 happens-before原则

### 6.1 happens-before是什么
happens-before不是指前面的操作必须先于后面的发生，而是指的是前面的操作结果对于后面操作可见

### 6.2 happens-before有哪些规则
#### 6.2.1 顺序性
同一个线程，前面的操作的结果对于后续操作可见  

#### 6.2.2 volatile规则
如果是volatile类型的变量，volatile的写操作结果对于读操作结果可见，即写操作happens-before于读操作结果

#### 6.2.3 管程锁规则
对一个锁的解锁happens-before与这个锁的加锁，比如synchronized。或者说一个锁加锁之后能看到加锁之前的操作  
```
synchronized (this) { // 此处自动加锁
    // x 是共享变量, 初始值 =10
    if (this.x < 12) {
        this.x = 12;
    }
} // 此处自动解锁
```
A线程如果此时已经改变了x =12,那么B线程重新获取所之后，发现x = 12,不满足条件，则不执行。  

#### 6.2.4 传递性规则
如果A happen-before于B，B happens-before于C,那么A 也happens-before于C， 如下：  
```java
public class VolatileExample {
    int x = 0;
    volatile boolean flag = false;
    public void writer() {
        x = 10;
        flag = true;
    }
    public void reader() {
        if (flag == true) {
            // 这里 x 会是多少呢
        }
    }
}

```
**我们可以分析如下：**  
![](.Java内存模型(JMM)_images/3625cd51.png)  

因为同一个线程的顺序性，所以x = 10 happens-before于flag = true;  
又因为volatile规则，volatile变量写操作happens-before读操作，所以 flag = true(写) happens-before于 flag = true(读  
根据传递规则：x = 10 happens-before于 flag = true(读)，所以B线程读到了flag = true,那么A线程设置的x=10,对于B线程也是可见的。  


#### 6.2.5 传递性规则
当一个线程启动的时候，能看见主线程之前的操作  
```
Thread B = new Thread(()->{
// 主线程调用 B.start() 之前
// 所有对共享变量的修改，此处皆可见
// 此例中，var==50
});
// 此处对共享变量 var 修改
var = 50;
// 主线程启动子线程
B.start();
```

#### 6.2.6 线程join规则(线程终止规则)
主线程等待子线程完成之后，对于子线程B的操作结果可见:  
```
Thread B = new Thread(()->{
    // 此处对共享变量 var 修改
    var = 10;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程 B 可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用 B.join() 之后皆可见
// 此例中，var==10
```

#### 6.2.7 final 变量规则
一个final域的变量初始化(构造方法执行完之前) happens-before于对它的引用，其实包括了对象终结规则，只要有对这个final域的访问，必须先确保final字段已经初始化过


#### 6.2.8  对象终结规则
一个对象在初始化(构造方法执行完之前)happens-before与它的终止,即调用它的finalize方法

