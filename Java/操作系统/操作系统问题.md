## 一 什么是线程与进程？它们的区别？
### 1.1 进程
进程指的就是正在运行中的代码程序，如果程序没有运行呢？那就是代码。所以我们判断是不是进程的最主要区别就是看程序是否正在运行  

* 第一: 它主要由代码段、数据段、进程控制块等组成
* 第二: 进程是操作系统进行资源分配的最小单位，每一个进程都拥有自己独立的资源
* 第三: 进程之间是相互独立的，一个进程不能自己去访问其他进程的资源等，需要通过操作系统提供的通信机制、数据共享机制等才可以进行访问
* 第四: 根据运行在内核空间还是用户空间不同，可以区分为内核进程和用户进程



**进程控制快(PCB)**:   
是process control block的缩写，用于管理进程各种信息  
Linux中，PCB就是一个结构体，有几百个字段，用于记录该进程运行时各种信息，比如进程ID，进程的名字，运行状态，创建时间，消耗时间，优先级，内存信息，程序计数器等等


### 1.2 线程
* 第一: 线程是进程的一部分  
* 第二: 是进程执行的最小单位
* 第三: 是CPU进行调度的基本单位

## 二 进程之间是如何通信的

### 2.1 共享存储(Shared Memory)
* 第一: 操作系统在内存中开辟一块空间，然后允许多个进程对这块内存区域进行读写操作，共享这块内存  
* 第二: 但是因为涉及到多个进程读写操作，因此要注意PV(互斥)并发访问问题，可以通过互斥锁或者信号量来保证数据一致性  

### 2.2 管道(Pipes)
* 第一: 管道是一种特殊的文件，每一个管道都有一个内核缓冲区，发送和接收数据都需要指定管道的文件描述符
* 第二: 管道传输的数据是字节流，不是一个结构化的数据，不太好确定消息边界，因此才把管道作为一个特殊的文件，这一点和消息队列不一样
* 第三: 管道是一种半双工的通信方式或者说单向的通信方式，只允许一个进程向管道发送数据，另外一个进程从管道读取数据。如果希望接收数据的进程给发送发送数据的进程发送消息，需要重新创建一个管道。因此管道这种方式进行进程之间通信效率比较低的

### 2.3 消息队列(Message Queue)
* 第一: 操作系统允许进程将消息发送到一个消息队列中，然后其他进程从这个进程中消费数据，实现进程之间异步通信
* 第二: 消息队列是一种全双工的通信方式，进程之间可以互相发送数据和接收数据

### 2.4 信号
* 操作系统允许一个进程给其他进程或者当前发送一个信号，然后其他进程收到信号后开始做一些处理  
* 常见的比如Linux中的kill函数，可以指定一个pid和要发送的信号  

### 2.5 套接字(Socket)
* 第一: 套接字是不同进程之间进行网络通信的机制，和管道类似，socket也是一个特殊文件，每一个socket都有一个文件描述符，然后发送很接收数据都需要通过指定文件描述符; 同样每一个socket也维护一个内核缓冲区，用于缓冲要发送或者读取的数据
* 第二: 和管道不一样，套接字是一种双工通信机制，两个进程之间可以互相发送和接收数据

### 2.6 文件
* 文件其实也可以作为进程之间通信，进程可以向文件写数据，也可以从文件读数据，只不过效率太低，因为会涉及到磁盘I/O  

## 四 同步和互斥
**临界资源**: 同一时间只能有一个进程访问或者操作共享资源我们也叫作临界资源(Critical Resource)或者互斥资源  
**临界区**: 进程中对临界资源或者互斥资源进行操作的代码片段叫做临界区(Critical Section/Region)  

### 4.1 同步机制
同步: 保证多个进程之间按照特定时序协同执行, 我搞好了，我把你叫醒；你搞好了把我叫醒。

#### 4.1.1 信号量(signal)机制
它的本质是一个计数器 + 阻塞队列，用于协调对共享资源的访问，防止竞争条件  
信号量提供两个原子操作:  
P(): 请求资源，信号量减一；如果为负，则阻塞线程  
V(): 释放资源，信号量加一；如果有线程阻塞，则唤醒一个  

#### 4.1.2 管程(monitor)机制
你可以把它看成一种自带锁的对象，提供对共享资源的安全访问  
它封装了共享变量、互斥锁和条件变量，因此宇哥一个管程包括如下信息:  
* 共享变量：要保护的临界资源
* 互斥机制(lock)：确保同一时间只有一个线程执行管程代码  
* 条件变量: 支持线程等待与通知机制
总结: 类似于Java中synchronized机制  


#### 4.1.3 PThread机制
PThread是一个多线程库，它提供了一系列函数和机制来支持多线程编程，包括线程的创建、销毁以及线程间的同步与互斥  
在并发编程中，多个线程可能会同时访问共享资源（如全局变量或文件），这可能导致数据不一致的问题。为了解决这个问题，pthread 提供了多种同步互斥机制，确保对共享资源的访问是安全的  
同步机制用于协调多个线程的执行顺序，确保某些线程在特定条件满足后才能继续执行。pthread 提供了 条件变量（Condition Variable） 来实现线程间的同步  
总结: 类似于Java中Lock机制

### 4.2 互斥机制
#### 4.2.1 软件实现方案
单标志法和双标志先检查法

#### 4.2.2 硬件实现方案
Test-and-Set (TAS)
使用硬件指令原子性地测试并设置某个标志位。如果标志位为 0，则允许进入临界区；否则循环等待 

Compare-and-Swap (CAS)
类似于 TAS，但提供了更复杂的比较和交换操作，广泛应用于现代多核处理器中

#### 4.2.3 高级同步机制
互斥锁（Mutex）
信号量（Semaphore）

## 五 死锁
### 5.1 什么是死锁
并发环境下，各进程或者线程因为竞争资源而导致都在等待获取对方手里的资源，导致各进程或者线程阻塞，都没办法向前推进，所以这就是死锁  

### 5.2 进程死锁、饥饿和死循环有什么区别
* 饥饿：指的是长期得不到想要资源，某进程或者线程无法向前推进，比如调度算法中的优先级调度，优先级低的可能很久都不会被调度，从而发生进程或者线程饥饿
* 死循环：某进程或者线程执行过程中，一直跳不出某个循环的现象，这个和并发没有关系，更多的是逻辑上的错误；而死锁更多是因为并发带来问题





## 六 CPU 调度算法（操作系统层面）
### 6.1 FCFS(先到先服务调度算法)
FCFS是First Come First Serve的缩写  
算法思想: 根据就绪队列的到达时间服务，此时就绪队列就是一个FIFO队列，后到的线程不能抢占前面正在服务的线程    
优点：简单和公平  
缺点：CPU进程区间太大；平均等待时间会变化很大  

### 6.2 SJF(最短作业优先调度)
SJF是Shortest Job First的缩写  
算法思想：选取就绪队列中需要CPU时间最短的进程  
第一：进程需要先预告自己需要多长CPU时间才能完成本次执行
第二：然后根据进程预告的时间，进行比较，时间最短的进程优执行；如果进程时间相同，则按照FCFS原则进行调度
第三：SJF可以是抢占的，也可以是不抢占的  
缺点: 耗时比较长的任务会一直处于被等待调度状态  


### 6.3 PSA(优先级调度算法)
PSA是Priority Scheduling Algorithm缩写  
第一：给每一个进程分配一个优先级，优先级越高的，越先执行。比如系统进程优先于用户进程  
第二：优先级算法可以是抢占式的，也可以是非抢占式的  
1. [ ] 抢占式: 新的进程到来，如果优先级高，则立即中断当前正在被CPU执行的进程，而执行当前的优先级高的线程  
2. [ ] 非抢占式: 等待当前进程运行完毕，或者时间分片到期再执行刚进入就绪队列高优先级的进程
特点：实现简单，但是不太公允。因为低优先级的进程可能很长时间无法执行，导致进程饥饿  

## 6.4 RR(时间片轮转调度算法)
RR是Round Robin的缩写  
第一：定义一个时间片，通常是10-100ms   
第二：在分配的时间片内，进程如果执行完毕，则调度下一个进程  
第三: 如果还未执行完成，则进入就绪队列，等待被再次调度，然后调度下一个进程，切换上下文等  
特点：公平，响应时间快；但是进程切换带来的消耗也是比较大的  


