## ä¸€ ä¼ ç»Ÿé˜»å¡æ¨¡å‹
### 1.1 ä¼ ç»Ÿé˜»å¡å•çº¿ç¨‹æ¨¡å‹
âœ…	æœåŠ¡å™¨ç«¯accept, é˜»å¡ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚  
âœ…	æ”¶åˆ°å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚ï¼Œåˆ›å»ºsocketæè¿°ç¬¦  
âœ…	è°ƒç”¨readå‡½æ•°ï¼Œæ ¹æ®socketæè¿°ç¬¦è¯»æ•°æ®  
âœ…	é˜»å¡ç­‰å¾…å†…æ ¸å‡†å¤‡æ•°æ®  
âœ…	æ•°æ®å‡†å¤‡å¥½ï¼Œè¿”å›æ•°æ®  

ğŸ¯ **ç¼ºç‚¹:**   
åªæœ‰ä¸€ä¸ªä¸»çº¿ç¨‹æ¥å¤„ç†ç½‘ç»œè¯·æ±‚è¿™ç§åŒæ­¥é˜»å¡æ¨¡å¼å¾ˆåƒåœ¾ï¼Œå› ä¸ºä¸€æ—¦æŸä¸ªå®¢æˆ·ç«¯å‘ç”Ÿé˜»å¡ï¼Œå°±ä¼šå½±å“å…¶ä»–å®¢æˆ·ç«¯  

ğŸ“– **ç¤ºä¾‹ä»£ç :**   
```java
import java.io.*;
import java.net.*;
public class SingleThreadBlockingServer {
    public static void main(String[] args) throws Exception {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("æœåŠ¡å¯åŠ¨ï¼Œç­‰å¾…å®¢æˆ·ç«¯è¿æ¥...");

        while (true) {
            Socket socket = serverSocket.accept(); // æ¥æ”¶è¿æ¥ï¼ˆé˜»å¡ï¼‰
            System.out.println("å®¢æˆ·ç«¯è¿æ¥ï¼š" + socket.getRemoteSocketAddress());

            // è¯»å–æ•°æ®ï¼ˆé˜»å¡ï¼‰
            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String line = reader.readLine();
            System.out.println("æ”¶åˆ°æ•°æ®ï¼š" + line);

            socket.close(); // å¤„ç†å®Œå…³é—­è¿æ¥
        }
    }
}
```

## 1.2 ä¼ ç»Ÿé˜»å¡å¤šçº¿ç¨‹æ¨¡å‹
âœ… æœåŠ¡å™¨ç«¯accept, é˜»å¡ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚  
âœ… æ”¶åˆ°è¿æ¥è¯·æ±‚ï¼Œä¸ºæ¯ä¸€ä¸ªå®¢æˆ·ç«¯åˆ›å»ºæˆ–è€…åˆ†é…ä¸€ä¸ªçº¿ç¨‹æ¥å¤„ç†å…·ä½“çš„ä¸šåŠ¡  
âœ… æ¯ä¸€ä¸ªçº¿ç¨‹ä¸­çš„I/Oæ“ä½œï¼Œå³ä¾¿é˜»å¡ï¼Œä¹Ÿåªæ˜¯é˜»å¡è‡ªå·±ï¼Œä¸ä¼šå½±å“å…¶ä»–å®¢æˆ·ç«¯  

ğŸ¯ **ç¼ºç‚¹:**  
å¦‚æœæœ‰å¤§é‡å®¢æˆ·ç«¯å‘èµ·ç½‘ç»œè¯·æ±‚ï¼Œé‚£ä¹ˆæœåŠ¡ç«¯å°±ä¼šåˆ›å»ºå¤§é‡çš„çº¿ç¨‹ï¼Œçº¿ç¨‹æ˜¯æ“ä½œç³»ç»Ÿä¸­æˆæœ¬æ¯”è¾ƒé«˜çš„èµ„æºï¼Œæ—¢ä¼šå ç”¨è¾ƒå¤šçš„å†…å­˜ï¼Œä¹Ÿä¼šé¢‘ç¹çš„è¿›è¡ŒCPUä¸Šçº¿æ–‡åˆ‡æ¢ï¼Œç³»ç»Ÿæ˜¯æ‰›ä¸ä½çš„

ğŸ“– **ç¤ºä¾‹ä»£ç :**  
```java
import java.io.*;
import java.net.*;

public class MultiThreadBlockingServer {
    public static void main(String[] args) throws Exception {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("æœåŠ¡å¯åŠ¨ï¼Œç­‰å¾…å®¢æˆ·ç«¯è¿æ¥...");

        while (true) {
            Socket socket = serverSocket.accept(); // æ¥æ”¶è¿æ¥ï¼ˆé˜»å¡ï¼‰
            new Thread(() -> handleClient(socket)).start(); // æ¯ä¸ªè¿æ¥æ–°èµ·ä¸€ä¸ªçº¿ç¨‹å¤„ç†
        }
    }

    private static void handleClient(Socket socket) {
        try {
            System.out.println("å¤„ç†å®¢æˆ·ç«¯ï¼š" + socket.getRemoteSocketAddress());
            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String line = reader.readLine(); // é˜»å¡ç­‰å¾…æ•°æ®
            System.out.println("æ”¶åˆ°æ•°æ®ï¼š" + line);

            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```


## äºŒ Reactorå•çº¿ç¨‹æ¨¡å‹
![](.ç½‘ç»œçº¿ç¨‹æ¨¡å‹ä¸“é¢˜_images/c2614c31.png)   

### 2.1 ä»€ä¹ˆæ˜¯Reactorå•çº¿ç¨‹æ¨¡å‹
âœ… æŒ‡çš„æ˜¯åˆ›å»ºè¿æ¥ã€ç›‘å¬äº‹ä»¶å’ŒI/Oæ“ä½œéƒ½æ˜¯åœ¨ç›¸åŒçš„Reactorçº¿ç¨‹ä¸­è¿›è¡Œçš„  

### 2.2 Reactorå•çº¿ç¨‹æ¨¡å‹è§’è‰²
âœ… ä¸»çº¿ç¨‹: Reactor  
âœ… AcceptHandler: åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥ï¼Œå¹¶å‘Selectoræ³¨å†Œï¼Œä»–æ˜¯è¿è¡Œåœ¨Reactorçº¿ç¨‹ä¹‹å†…çš„  
âœ… DataHandler: ä¸šåŠ¡å¤„ç†å™¨ï¼Œå¤„ç†è¯»å†™I/Oäº‹ä»¶ï¼Œä»–æ˜¯è¿è¡Œåœ¨Reactorçº¿ç¨‹ä¹‹å†…çš„  

### 2.3 å·¥ä½œæµç¨‹
#### 2.3.1 Reactorçº¿ç¨‹
âœ… åˆ›å»ºReactorçº¿ç¨‹ï¼Œå¹¶å¯åŠ¨Reactorçº¿ç¨‹  
âœ… Reactorçº¿ç¨‹åˆå§‹åŒ–çš„æ—¶å€™:  
1. [ ] ä¼šåˆå§‹åŒ–Selector
2. [ ] åˆ›å»ºServerSocketChannel
3. [ ] å‘Selectoræ³¨å†ŒServerSocketChannelï¼Œç›‘è§†ON_ACCEPTäº‹ä»¶
4. [ ] ç»‘å®šAcceptHandler

âœ… Reactorçº¿ç¨‹è¿è¡Œçš„æ—¶å€™:  
1. [ ] ä¸æ–­çš„è½®è¯¢ï¼Œä»Selectorè·å–å°±ç»ªäº‹ä»¶
2. [ ] å¦‚æœæœ‰äº‹ä»¶å°±ç»ªï¼Œæ ¹æ®äº‹ä»¶ç±»å‹è¿›è¡Œdispatchåˆ†å‘:

* å¦‚æœæ˜¯ACCEPTäº‹ä»¶ï¼Œåˆ™è°ƒç”¨AcceptHandlerçš„runæ–¹æ³•
* å¦‚æœæ˜¯è¯»å†™äº‹ä»¶å°±ç»ªï¼Œåˆ™è°ƒç”¨DataHandlerçš„runæ–¹æ³•

#### 2.3.2 AcceptHandler:
âœ… æ¥æ”¶è¿æ¥, åˆ›å»ºSocketChannel   
âœ… å°†SocketChannelæ³¨å†Œåˆ° Selector ä¸Šï¼Œç»‘å®šä¸€ä¸ªæ–°çš„ä¸šåŠ¡Handlerï¼Œ ç›‘å¬æ„Ÿå…´è¶£çš„è¯»å†™äº‹ä»¶    

#### 2.3.3 DataHandler:
âœ… è¯»æ•°æ®ï¼šSocketChannel.read()ï¼Œç¼“å­˜åˆ°ç¼“å†²åŒº  
âœ… å†™æ•°æ®ï¼šSocketChannel.write()ï¼Œå°†ç¼“å†²åŒºå†…å®¹å‘é€å›å®¢æˆ·ç«¯  


### 2.4 ç¤ºä¾‹ä»£ç 
```java
public class Main {
    public static void main(String[] args) throws IOException {
        new Thread(new Reactor(8080)).start();
    }
}



public class Reactor implements Runnable {
    private final Selector selector;
    private final ServerSocketChannel serverSocket;

    public Reactor(int port) throws IOException {
        selector = Selector.open();
        serverSocket = ServerSocketChannel.open();
        serverSocket.bind(new InetSocketAddress(port));
        serverSocket.configureBlocking(false);
        SelectionKey sk = serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        sk.attach(new AcceptorHandler());
    }

    @Override
    public void run() {
        try {
            while (!Thread.interrupted()) {
                selector.select(); // é˜»å¡ç­‰å¾…å°±ç»ªäº‹ä»¶
                Iterator<SelectionKey> it = selector.selectedKeys().iterator();
                while (it.hasNext()) {
                    SelectionKey key = it.next();
                    dispatch(key);
                    it.remove();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void dispatch(SelectionKey key) {
        Runnable handler = (Runnable) key.attachment();
        if (handler != null) handler.run(); // è¿™é‡Œè°ƒç”¨EchoHandler.runæ‰§è¡ŒI/Oæ“ä½œ
    }

    // AcceptorHandler å†…éƒ¨ç±»
    class AcceptorHandler implements Runnable {
        @Override
        public void run() {
            try {
                SocketChannel client = serverSocket.accept();
                if (client != null) {
                    new EchoHandler(selector, client); // è¿™é‡Œåªæ˜¯åˆ›å»ºï¼Œå¹¶æ²¡æœ‰å¯åŠ¨ï¼Œå¹¶ä¸æ˜¯ä»¥çº¿ç¨‹æ–¹å¼è¿è¡Œ
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}



public class EchoHandler implements Runnable {
    private final SocketChannel socket;
    private final SelectionKey sk;
    private final ByteBuffer buffer = ByteBuffer.allocate(1024);
    private static final int READING = 0, SENDING = 1;
    private int state = READING;

    public EchoHandler(Selector selector, SocketChannel client) throws IOException {
        socket = client;
        socket.configureBlocking(false);
        sk = socket.register(selector, SelectionKey.OP_READ);
        sk.attach(this);
        selector.wakeup(); // å”¤é†’ selector ç«‹å³å¤„ç†æ³¨å†Œ
    }

    @Override
    public void run() {
        try {
            if (state == READING) read();
            else if (state == SENDING) send();
        } catch (IOException e) {
            e.printStackTrace();
            sk.cancel();
            try { socket.close(); } catch (IOException ex) { }
        }
    }

    private void read() throws IOException {
        int len = socket.read(buffer);
        if (len > 0) {
            buffer.flip();
            state = SENDING;
            sk.interestOps(SelectionKey.OP_WRITE);
        }
    }

    private void send() throws IOException {
        socket.write(buffer);
        if (!buffer.hasRemaining()) {
            buffer.clear();
            state = READING;
            sk.interestOps(SelectionKey.OP_READ);
        }
    }
}

```

## ä¸‰ Reactorå¤šçº¿ç¨‹æ¨¡å‹
![](.ç½‘ç»œçº¿ç¨‹æ¨¡å‹ä¸“é¢˜_images/f3d92be1.png)  
ğŸ’¡ **æ³¨æ„:** æœ‰çš„åœ°æ–¹AcceptHandlerå¹¶æ²¡æœ‰ä½¿ç”¨çº¿ç¨‹æ±   

### 3.1 ä»€ä¹ˆæ˜¯Reactorå¤šçº¿ç¨‹æ¨¡å‹
âœ… åˆ›å»ºè¿æ¥ã€ç›‘å¬äº‹ä»¶åœ¨Reactorçº¿ç¨‹ä¸­æ‰§è¡Œï¼Œä½†æ˜¯I/Oäº‹ä»¶æäº¤ç»™çº¿ç¨‹æ± ä¸­æ‰§è¡Œï¼Œå°†I/Oäº‹ä»¶å¼‚æ­¥è§£è€¦ï¼Œæå‡Reactorçº¿ç¨‹æ‰§è¡Œæ•ˆç‡   

### 3.2 Reactorå•çº¿ç¨‹å’ŒReactorå¤šçº¿ç¨‹æ¯”è¾ƒ
âœ… Reactorå•çº¿ç¨‹: ä¸šåŠ¡Handleræ‰§è¡Œæ˜¯åœ¨Reactorä¸»çº¿ç¨‹è¿›è¡Œçš„    
âœ… Reactorå¤šçº¿ç¨‹: ä¸šåŠ¡Handleræ‰§è¡Œæ˜¯æäº¤ç»™çº¿ç¨‹æ± æ‰§è¡Œçš„ï¼Œè€Œä¸æ˜¯Reactorä¸»çº¿ç¨‹    

### 3.3 Reactorå¤šçº¿ç¨‹æ¨¡å‹è§’è‰²
âœ… ä¸»çº¿ç¨‹: Reactor  
âœ… AcceptHandler: åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥ï¼Œå¹¶å‘Selectoræ³¨å†Œï¼Œä»–æ˜¯è¿è¡Œåœ¨Reactorçº¿ç¨‹ä¹‹å†…çš„  
âœ… DataHandler: ä¸šåŠ¡å¤„ç†å™¨ï¼Œå¤„ç†è¯»å†™I/Oäº‹ä»¶ï¼Œä»–æ˜¯è¿è¡Œåœ¨Reactorçº¿ç¨‹ä¹‹å†…çš„  
âœ… çº¿ç¨‹æ± : æ‰§è¡Œæäº¤çš„DataHandlerä»»åŠ¡  

### 3.4 å·¥ä½œæµç¨‹
#### 3.4.1 Reactorçº¿ç¨‹
âœ… åˆ›å»ºReactorçº¿ç¨‹ï¼Œå¹¶å¯åŠ¨Reactorçº¿ç¨‹  
âœ… Reactorçº¿ç¨‹åˆå§‹åŒ–çš„æ—¶å€™:  
1. [ ] ä¼šåˆå§‹åŒ–Selector
2. [ ] åˆ›å»ºServerSocketChannel
3. [ ] å‘Selectoræ³¨å†ŒServerSocketChannelï¼Œç›‘è§†ON_ACCEPTäº‹ä»¶
4. [ ] ç»‘å®šAcceptHandler

âœ… Reactorçº¿ç¨‹è¿è¡Œçš„æ—¶å€™:  
1. [ ] ä¸æ–­çš„è½®è¯¢ï¼Œä»Selectorè·å–å°±ç»ªäº‹ä»¶  
2. [ ] å¦‚æœæœ‰äº‹ä»¶å°±ç»ªï¼Œæ ¹æ®äº‹ä»¶ç±»å‹è¿›è¡Œdispatchåˆ†å‘:  

* å¦‚æœæ˜¯ACCEPTäº‹ä»¶ï¼Œåˆ™è°ƒç”¨AcceptHandlerçš„runæ–¹æ³•  
* å¦‚æœæ˜¯è¯»å†™äº‹ä»¶å°±ç»ªï¼Œåˆ™å°†DataHandleræäº¤ç»™çº¿ç¨‹æ± æ‰§è¡Œ  

#### 3.4.2 AcceptHandler
âœ… æ¥æ”¶è¿æ¥, åˆ›å»ºSocketChannel   
âœ… å°†SocketChannelæ³¨å†Œåˆ° Selector ä¸Šï¼Œç»‘å®šä¸€ä¸ªæ–°çš„ä¸šåŠ¡Handlerï¼Œ ç›‘å¬æ„Ÿå…´è¶£çš„è¯»å†™äº‹ä»¶  

#### 3.4.3 DataHandler
âœ… è¯»æ•°æ®ï¼šSocketChannel.read()ï¼Œç¼“å­˜åˆ°ç¼“å†²åŒº  
âœ… å†™æ•°æ®ï¼šSocketChannel.write()ï¼Œå°†ç¼“å†²åŒºå†…å®¹å‘é€å›å®¢æˆ·ç«¯  

### 3.5 ç¤ºä¾‹ä»£ç 
```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThreadReactorServer {
    private Selector selector;
    private ServerSocketChannel serverSocketChannel;
    private ExecutorService workerPool;

    public MultiThreadReactorServer(int port, int workerThreads) throws IOException {
        selector = Selector.open();
        serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.bind(new InetSocketAddress(port));
        serverSocketChannel.configureBlocking(false);

        // æ³¨å†Œacceptäº‹ä»¶
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        // çº¿ç¨‹æ± å¤„ç†è¯»å†™ä¸šåŠ¡
        workerPool = Executors.newFixedThreadPool(workerThreads);
    }

    public void start() throws IOException {
        System.out.println("Server started on port ...");

        while (true) {
            selector.select(); // é˜»å¡ç­‰å¾…å°±ç»ªäº‹ä»¶
            Set<SelectionKey> keys = selector.selectedKeys();
            Iterator<SelectionKey> it = keys.iterator();

            while (it.hasNext()) {
                SelectionKey key = it.next();
                it.remove();

                if (key.isAcceptable()) {
                    handleAccept();
                } else if (key.isReadable()) {
                    // è¯»äº‹ä»¶äº¤ç»™çº¿ç¨‹æ± å¼‚æ­¥å¤„ç†
                    key.interestOps(key.interestOps() & ~SelectionKey.OP_READ); // å…ˆå–æ¶ˆè¯»ç›‘å¬ï¼Œé˜²æ­¢é‡å¤è§¦å‘
                    workerPool.submit(new ReadHandler(key));
                }
            }
        }
    }

    private void handleAccept() throws IOException {
        SocketChannel client = serverSocketChannel.accept();
        client.configureBlocking(false);
        System.out.println("Accepted connection from " + client.getRemoteAddress());

        // æ³¨å†Œè¯»äº‹ä»¶ï¼Œç›‘å¬å®¢æˆ·ç«¯æ•°æ®
        client.register(selector, SelectionKey.OP_READ);
    }

    // è¯»å–å®¢æˆ·ç«¯æ•°æ®ä»»åŠ¡
    private class ReadHandler implements Runnable {
        private SelectionKey key;

        public ReadHandler(SelectionKey key) {
            this.key = key;
        }

        @Override
        public void run() {
            SocketChannel client = (SocketChannel) key.channel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = 0;
            try {
                bytesRead = client.read(buffer);
                if (bytesRead > 0) {
                    buffer.flip();
                    byte[] data = new byte[buffer.remaining()];
                    buffer.get(data);

                    String received = new String(data);
                    System.out.println("Received: " + received);

                    // Echo å›å®¢æˆ·ç«¯
                    buffer.clear();
                    buffer.put(("Echo: " + received).getBytes());
                    buffer.flip();
                    while (buffer.hasRemaining()) {
                        client.write(buffer);
                    }
                } else if (bytesRead == -1) {
                    // å®¢æˆ·ç«¯å…³é—­è¿æ¥
                    System.out.println("Client disconnected: " + client.getRemoteAddress());
                    client.close();
                    key.cancel();
                    return;
                }
            } catch (IOException e) {
                e.printStackTrace();
                try {
                    client.close();
                } catch (IOException ex) {
                }
                key.cancel();
            } finally {
                // é‡æ–°å¼€å¯è¯»ç›‘å¬
                if (key.isValid()) {
                    key.interestOps(key.interestOps() | SelectionKey.OP_READ);
                    selector.wakeup();  // é‡è¦ï¼Œå”¤é†’selectorï¼Œæ›´æ–°äº‹ä»¶æ³¨å†Œ
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        MultiThreadReactorServer server = new MultiThreadReactorServer(9000, 4);
        server.start();
    }
}
```

## å›› ä¸»ä»Reactorå¤šçº¿ç¨‹æ¨¡å‹
### 4.1 ä»€ä¹ˆæ˜¯ä¸»ä»Reactorå¤šçº¿ç¨‹æ¨¡å‹
âœ… å°±æ˜¯å°†ä»¥å‰å•ä¸ªReactorï¼Œæ‹†åˆ†æˆ2éƒ¨åˆ†Reactor: MainReactorå’ŒSubReactor  

### 4.2 ä¸»ä»Reactorå¤šçº¿ç¨‹æ¨¡å‹è§’è‰²æœ‰å“ªäº›
âœ… MainReactor: å°†æ–°åˆ›å»ºçš„çš„ServersocketSocketChannelæ³¨å†Œåˆ°Selectorï¼Œ ä¸»è¦æ˜¯ç›‘å¬ON_ACCEPTäº‹ä»¶  
âœ… SubReactor: å°†æ–°åˆ›å»ºçš„çš„SocketChannelæ³¨å†Œåˆ°Selector, å¾ªç¯ç›‘å¬å°±ç»ªçš„I/Oäº‹ä»¶   
âœ… AcceptHandler: åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥ï¼Œå¹¶å‘Selectoræ³¨å†Œï¼Œä»–æ˜¯è¿è¡Œåœ¨Reactorçº¿ç¨‹ä¹‹å†…çš„  
âœ… DataHandler: ä¸šåŠ¡å¤„ç†å™¨ï¼Œå¤„ç†è¯»å†™I/Oäº‹ä»¶ï¼Œä»–æ˜¯è¿è¡Œåœ¨Reactorçº¿ç¨‹ä¹‹å†…çš„  
âœ… çº¿ç¨‹æ± : æ‰§è¡Œæäº¤çš„DataHandlerä»»åŠ¡  

### 4.3 å·¥ä½œæµç¨‹
![](.ç½‘ç»œçº¿ç¨‹æ¨¡å‹ä¸“é¢˜_images/d7b55d35.png)  
#### 4.3.1 MainReactor
âœ… åˆ›å»ºSelector  
âœ… åˆ›å»ºServerSocketChannel,è®©åå°†å…¶æ³¨å†Œåˆ°Selectorï¼Œç›‘å¬ON_ACCEPTäº‹ä»¶  
âœ… è´Ÿè´£åˆå§‹åŒ–å’Œå¯åŠ¨ä»Reactor  
âœ… ç›‘å¬åˆ°ON_ACCEPTäº‹ä»¶ï¼Œåˆ›å»ºSocketChannel, ç„¶åä»Reactorä¸­é€‰æ‹©ä¸€ä¸ªReactorå»å‘Selectoræ–°æ³¨å†Œåˆ›å»ºçš„SocketChannelï¼Œä»¥åŠç›‘å¬è¯»å†™äº‹ä»¶  

#### 4.3.1 SubReactor
âœ… åˆ›å»ºSelector
âœ… ä»Reactoræœ¬èº«æ˜¯ä¸€ä¸ªå•ç‹¬çš„çº¿ç¨‹ï¼Œä»–åœ¨åˆå§‹åŒ–çš„æ—¶å€™ä¼šåˆå§‹åŒ–çº¿ç¨‹æ± 
âœ… ç„¶åå½“ä»Reactorç›‘å¬åˆ°å°±ç»ªäº‹ä»¶ï¼Œåˆ›å»ºä¸šåŠ¡Handleräº¤ç»™çº¿ç¨‹æ± æ‰§è¡Œ

### 4.4 ç¤ºä¾‹ä»£ç 
```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MasterSlaveReactor {
    // ä¸» Reactor çº¿ç¨‹
    static class MainReactor implements Runnable {
        private final Selector selector;
        private final ServerSocketChannel serverSocket;
        private final SubReactor[] subReactors;
        private int nextSubReactor = 0;

        public MainReactor(int port, int subReactorCount) throws IOException {
            selector = Selector.open();
            serverSocket = ServerSocketChannel.open();
            serverSocket.bind(new InetSocketAddress(port));
            serverSocket.configureBlocking(false);
            serverSocket.register(selector, SelectionKey.OP_ACCEPT);

            subReactors = new SubReactor[subReactorCount];
            for (int i = 0; i < subReactorCount; i++) {
                subReactors[i] = new SubReactor();
                new Thread(subReactors[i], "SubReactor-" + i).start();
            }
        }

        @Override
        public void run() {
            System.out.println("MainReactor started...");
            try {
                while (true) {
                    selector.select();
                    Set<SelectionKey> keys = selector.selectedKeys();
                    Iterator<SelectionKey> it = keys.iterator();

                    while (it.hasNext()) {
                        SelectionKey key = it.next();
                        it.remove();

                        if (key.isAcceptable()) {
                            acceptClient();
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        private void acceptClient() throws IOException {
            SocketChannel client = serverSocket.accept();
            client.configureBlocking(false);
            System.out.println("Accepted connection from " + client.getRemoteAddress());

            // è½®è¯¢åˆ†é…ç»™æŸä¸ªä» Reactor
            SubReactor subReactor = subReactors[nextSubReactor];
            nextSubReactor = (nextSubReactor + 1) % subReactors.length;
            subReactor.registerChannel(client);
        }
    }

    // ä» Reactor çº¿ç¨‹
    static class SubReactor implements Runnable {
        private final Selector selector;
        private final ExecutorService workerPool = Executors.newFixedThreadPool(4);

        public SubReactor() throws IOException {
            selector = Selector.open();
        }

        // ä¸» Reactor è°ƒç”¨æ­¤æ–¹æ³•ï¼Œå°†æ–°è¿æ¥æ³¨å†Œåˆ°ä» Reactor Selector
        public void registerChannel(SocketChannel channel) throws IOException {
            selector.wakeup();
            channel.register(selector, SelectionKey.OP_READ, new Handler(channel, selector, workerPool));
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " started...");
            try {
                while (true) {
                    selector.select();

                    Set<SelectionKey> keys = selector.selectedKeys();
                    Iterator<SelectionKey> it = keys.iterator();

                    while (it.hasNext()) {
                        SelectionKey key = it.next();
                        it.remove();

                        if (key.isReadable()) {
                            Handler handler = (Handler) key.attachment();
                            // æäº¤çº¿ç¨‹æ± å¤„ç†è¯»å†™
                            workerPool.submit(handler);
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // ä¸šåŠ¡å¤„ç†å™¨ï¼Œè´Ÿè´£è¯»å†™å’Œä¸šåŠ¡é€»è¾‘å¤„ç†
    static class Handler implements Runnable {
        private final SocketChannel channel;
        private final Selector selector;
        private final ExecutorService workerPool;
        private final ByteBuffer buffer = ByteBuffer.allocate(1024);

        public Handler(SocketChannel channel, Selector selector, ExecutorService workerPool) {
            this.channel = channel;
            this.selector = selector;
            this.workerPool = workerPool;
        }

        @Override
        public void run() {
            try {
                int bytesRead = channel.read(buffer);
                if (bytesRead > 0) {
                    buffer.flip();
                    byte[] data = new byte[buffer.remaining()];
                    buffer.get(data);
                    String received = new String(data);
                    System.out.println(Thread.currentThread().getName() + " received: " + received);

                    // ä¸šåŠ¡å¤„ç†ï¼ˆç¤ºä¾‹ï¼šç®€å• echoï¼‰
                    buffer.clear();
                    buffer.put(("Echo: " + received).getBytes());
                    buffer.flip();

                    while (buffer.hasRemaining()) {
                        channel.write(buffer);
                    }
                } else if (bytesRead == -1) {
                    System.out.println("Client closed: " + channel.getRemoteAddress());
                    channel.close();
                }
            } catch (IOException e) {
                try {
                    channel.close();
                } catch (IOException ex) {
                }
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws IOException {
        int port = 9000;
        int subReactorCount = 2;

        MainReactor mainReactor = new MainReactor(port, subReactorCount);
        new Thread(mainReactor, "MainReactor").start();
    }
}
```

