## 一 什么是线程池? 为什么需要线程池? 线程池使用场景
### 1.1 什么是线程池? 为什么需要使用线程池
✅ 线程池是一种池化技术  
✅ 可以用于线程的管理，实现线程并发数量的控制、线程资源的复用  
✅ 从而减少了系统中线程无限膨胀或者线程频繁创建和销毁带来的性能影响  

### 1.2 线程池使用场景
✅ 高并发请求处理  
✅ 大任务拆分成多个子任务  
✅ 串行任务并行化  


## 二 线程池实现原理

### 2.1 线程池有哪些角色
✅ 线程工厂: 创建Work线程的工厂对象  
✅ 工作者线程: 执行任务的线程  
✅ 任务队列: 超过核心线程数后，用于堆积任务  
✅ 拒绝策略处理器：拒绝执行任务时的处理策略  

### 2.2 线程池参数
❗ corePoolSize: 核心线程数  
❗ maximumPoolSize: 最大线程数  
❗ keepAliveTime: 线程回收前最大空闲时间  
❗ workQueue: 任务队列, 一般是有界队列；如果不希望任务放队列，可以设置SynchronizedQueue同步队列  
❗ threadFactory: 创建工作者线程的工厂   
❗ handler: 拒绝策略处理器  

### 2.3 线程池状态 以及状态如何转换的
#### 2.3.1 线程池有哪些状态
👉 RUNNING: 接收新任务; 处理任务；线程不会中断  
👉 SHUTDOWN: 不接收新任务；会继续处理没处理完的任务; 线程不会中断  
👉 STOP: 不接收新任务; 也没任务处理; 开始将线程中断  
👉 TIDY: 不接收新任务; 也没任务处理；所有线程全部中断；准备调用terminated的钩子方法  
👉 TERMINATED:不接收新任务; 也没任务处理；所有线程全部中断；也不会调用任何方法，表示整个线程池资源可以被回收  

#### 2.3.2 线程池状态是如何
👉 RUNNING -> SHUTDOWN：调用shutdown方法  
👉 RUNNING/SHUTDOWN -> STOP：调用shutdownNow方法  
👉 STOP -> TIDY: 当队列和线程池中的线程都是空的，所有线程全部被中断  
👉 TIDY -> TERMINATED: 调用terminated方法  

### 2.4 线程池工作流程
1. [ ] 当线程池提交任务，线程池判断当前线程数量是否超过核心线程数量: 如果没超过则通过线程工厂创建一个新的工作和线程，并且把提交任务给他执行
2. [ ] 如果当前线程数量已经 >= 核心线程数量，则尝试往任务队列添加任务
3. [ ] 如果任务队列已满，则判断当前线程数量是否超过最大允许线程数量: 如果没超过则通过线程工厂创建一个新的工作和线程，并且把提交任务给他执行
4. [ ] 如果已经达到最大线程数量阈值，则根据拒绝策略处理器开始进行任务拒绝处理
5. [ ] 当一个线程执行完毕后，会从任务队列去捞取任务执行
6. [ ] 如果任务队列没有任务，则该线程会阻塞等待设置的超时时间或者空闲时间，如果到期还没有任务，则该线程会被回收
7. [ ] 回收线程，默认情况下最少要保留核心线程数量那么多线程，除非设置了允许核心线程被回收

### 2.5 拒绝策略
#### 2.5.1 AbortPolicy(抛出异常)
线程池拒绝任务并抛出RejectedExecutionException异常  

#### 2.5.2 DiscardPolicy(丢弃当前任务)
线程池拒绝任务, 但是不抛出异常

#### 2.5.3 DiscardOldestPolicy(丢弃队列中最老的任务)
线程池丢弃任务队列最老的任务, 但是不抛出异常

#### 2.5.4 CallerRunsPolicy(由提交任务线程继续执行)
线程池拒绝任务并将任务返回给提交任务的线程，由提交任务的线程自己执行，不受线程池管理。也就是不是从线程池获取线程来执行任务，而是由执行当前程序的线程来执行任务  
优点: 不会丢弃任务  
缺点: 可能会影响提交任务线程的性能；或者提交任务的线程也是线程池中的线程，那么可能导致线程池其他线程处于等待状态  

## 三 线程池的回收
### 3.1 任务队列没有任务，并且线程池超过核心线程数量
任务队列没有任务，然后当前的存活的工作线程数量超过核心线程数量。这时候，捞取任务的线程超过了keepAliveTime空闲存活时间，超时之后，线程池会从线程池缓存中获取一个线程进行回收  

### 3.2 关闭线程池
当调用线程池的shutdown()或shutdownNow()方法关闭线程池时，线程池会回收所有的线程

## 四 线程池工作线程出现异常怎么处理
✅ 第一: 可以在定义任务的时候，捕获异常进行处理  
✅ 第二: 可以在执行完任务后，通过返回的Future对象进行get捕获异常再进行处理  
✅ 第三: 构造线程池的时候，可以指定线程工厂，那么线程工厂可以自定义未捕获异常处理  

## 五 线程池参数调优
**理论线程数设置：**
线程数 = CPU核心数 * （1 + 线程等待时间 / 线程总运行时间）线程等待时间可以通过Linux系统命令去观察，线程总运行时间可以根据时间统计得出  

**计算密集型任务:**  
线程数 = CPU核心 + 1  
这个主要是考虑到某一个线程被突然中断了，那么CPU就没事干了，因此可以考虑额外补充一个线程  

**I/O密集型任务：**  
线程数 = 2 * CPU核心数  
因为大部分时间都是在阻塞上面，如果是4个核心的CPU，那么每一个I/O线程都在阻塞，那么每一个CPU相当于都没活干了  
但是在实际工作中，需要压测才可以得到一个准确的线程数。通过指定核心线程数观察压测时候比较耗时大小，一般来说核心线程数可以设置的稍微小一点，然后最大线程数通过压测确定耗时最小的拐点的值作为最大线程数  

🎯 **注意: 可以关注的CPU指标**  
**Load Average(平均负载)**   
👉 Load Average是一个系统的负载指标，它表示在一段时间内正在运行和等待运行的进程数  
👉 通过查看Load Average的数值，可以大致了解系统的繁忙程度  
👉 较高的Load Average值通常表示系统处于高负载状态，线程可能需要等待较长时间才能得到执行  
👉 通常Load Average的数值会显示为三个数字，分别代表最近1分钟、5分钟和15分钟内的平均负载  
👉 通常情况下，Load Average小于1表示系统负载较低，接近1表示系统负载适中，大于1表示系统负载较高。在Linux系统中，可以使用命令`uptime`或`top`来查看当前的Load Average数值  

**CPU使用率**  
👉 通过查看每个线程的CPU使用率，可以了解线程在CPU上的运行时间和等待时间   
👉 工具如top、htop和sar可以提供实时的CPU使用率信息  

**I/O等待时间**  
👉 通过查看每个线程的I/O等待时间，可以了解线程在等待I/O操作完成时花费的时间  
👉 工具如iostat和iotop可以提供实时的I/O等待时间信息  

**上下文切换次数**  
👉 上下文切换是指从一个线程或进程切换到另一个线程或进程的过程  
👉 通过查看上下文切换的次数，可以了解线程在等待时间和运行时间之间的切换频率  
👉 工具如vmstat和sar可以提供上下文切换次数的信息   

**系统调用次数**  
👉 系统调用是线程与操作系统之间的接口，用于请求操作系统提供服务  
👉 通过查看系统调用的次数，可以了解线程在等待操作系统服务时的时间  
👉 工具如strace和perf可以提供系统调用次数的信息  

## 六 线程池在使用过程中遇到的线上问题
### 6.1 线程池资源耗尽
当提交的任务太多，当前工作者线程已经超过最大工作者线程，新提交的任务就会被拒绝。此时根据不同的策略优点直接可能放弃，有的可是直接新开线程等

### 6.2 线程池配置不合理
线程池的核心线程数、最大线程数、任务队列大小等配置参数需要根据系统的负载情况和性能需求进行合理的配置，否则可能会导致线程池性能不佳或资源浪费

### 6.3 异常处理
没有合适的异常处理机制，可能会导致线程池中的线程被终止，影响其他任务的执行

### 6.4 死锁
如果线程池中的任务存在相互依赖或者资源竞争的情况，可能会导致死锁，使得线程池无法继续执行任务

### 6.5 线程安全
如果线程池中的任务没有正确处理共享资源的同步访问，可能会导致数据不一致或者线程安全问题
